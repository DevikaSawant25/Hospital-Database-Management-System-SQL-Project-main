Hospital Management System (HMS)

Oracle PL/SQL–backed Hospital Management System with a Python (Flask) API for patient registration, appointments, billing, and doctor scheduling. Focuses on data integrity, stored procedures/triggers, and performance-tuned SQL—ideal for Oracle/PLSQL developer workflows.

Table of Contents

Overview

Key Features

Architecture

Tech Stack

Database Schema

PL/SQL Objects

API Endpoints

Setup & Installation

Sample Data & Queries

Performance & Indexing

Testing

Security

Backup & Recovery

Project Structure

Roadmap

License

Overview

The HMS centralizes core hospital workflows:

Patient onboarding and history

Doctor schedules and appointment booking

Billing (consultations, procedures, pharmacy items)

Administrative reports (revenue, occupancy, no-show rates)

The system leverages Oracle tables, constraints, packages, procedures, functions, and triggers to enforce business rules, with a Flask REST layer for integration.

Key Features

ACID-safe Oracle schema with PK/FK, check constraints, and unique keys

PL/SQL packages for appointments, billing, and auditing

Triggers for automatic invoice totals, audit logs, and data validation

Flask REST API for CRUD + reporting endpoints

Role-based access (admin, doctor, receptionist) at the app layer

Performance tuning via indexes, bind variables, and execution plan reviews

Architecture
[Client/UI or Postman]  →  Flask API  →  cx_Oracle Driver  →  Oracle DB (PL/SQL)
                                     ↘  Logging/Monitoring

Tech Stack

Database: Oracle 12c+ (SQL, PL/SQL)

API: Python 3.10+, Flask

Driver: cx_Oracle / oracledb

Auth (optional): JWT

Dev Tools: SQL Developer, DBeaver, Postman, pytest

Database Schema

Core tables (minimum viable):

PATIENTS(patient_id PK, first_name, last_name, dob, gender, phone, email, created_at)

DOCTORS(doctor_id PK, first_name, last_name, specialization, phone, email, is_active)

ROOMS(room_id PK, room_type, daily_rate, is_occupied)

APPOINTMENTS(appt_id PK, patient_id FK, doctor_id FK, appt_time, status, notes)

BILLING(invoice_id PK, patient_id FK, appt_id FK, amount NUMERIC, tax NUMERIC, discount NUMERIC, total NUMERIC, status, created_at)

BILLING_ITEMS(item_id PK, invoice_id FK, item_type, description, unit_price, qty, line_total)

AUDIT_LOG(log_id PK, entity_name, entity_id, action, changed_by, changed_at)

DDL (excerpt):

CREATE TABLE PATIENTS (
  patient_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  first_name      VARCHAR2(50) NOT NULL,
  last_name       VARCHAR2(50) NOT NULL,
  dob             DATE NOT NULL,
  gender          CHAR(1) CHECK (gender IN ('M','F','O')),
  phone           VARCHAR2(15),
  email           VARCHAR2(100) UNIQUE,
  created_at      DATE DEFAULT SYSDATE
);

CREATE TABLE DOCTORS (
  doctor_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  first_name      VARCHAR2(50) NOT NULL,
  last_name       VARCHAR2(50) NOT NULL,
  specialization  VARCHAR2(80) NOT NULL,
  phone           VARCHAR2(15),
  email           VARCHAR2(100) UNIQUE,
  is_active       CHAR(1) DEFAULT 'Y' CHECK (is_active IN ('Y','N'))
);

CREATE TABLE APPOINTMENTS (
  appt_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  patient_id NUMBER NOT NULL REFERENCES PATIENTS(patient_id),
  doctor_id  NUMBER NOT NULL REFERENCES DOCTORS(doctor_id),
  appt_time  DATE NOT NULL,
  status     VARCHAR2(20) CHECK (status IN ('SCHEDULED','COMPLETED','CANCELLED','NO_SHOW')),
  notes      VARCHAR2(4000)
);

PL/SQL Objects
Package: pkg_appointments
CREATE OR REPLACE PACKAGE pkg_appointments AS
  PROCEDURE book_appointment(p_patient_id IN NUMBER, p_doctor_id IN NUMBER, p_time IN DATE, p_appt_id OUT NUMBER);
  PROCEDURE cancel_appointment(p_appt_id IN NUMBER);
  FUNCTION  doctor_availability(p_doctor_id IN NUMBER, p_time IN DATE) RETURN CHAR; -- 'Y'/'N'
END pkg_appointments;
/

CREATE OR REPLACE PACKAGE BODY pkg_appointments AS
  FUNCTION doctor_availability(p_doctor_id IN NUMBER, p_time IN DATE) RETURN CHAR IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM APPOINTMENTS
    WHERE doctor_id = p_doctor_id
      AND status = 'SCHEDULED'
      AND ABS((p_time - appt_time) * 24*60) < 30; -- 30-min window
    RETURN CASE WHEN v_cnt = 0 THEN 'Y' ELSE 'N' END;
  END;

  PROCEDURE book_appointment(p_patient_id IN NUMBER, p_doctor_id IN NUMBER, p_time IN DATE, p_appt_id OUT NUMBER) IS
  BEGIN
    IF doctor_availability(p_doctor_id, p_time) = 'N' THEN
      RAISE_APPLICATION_ERROR(-20001, 'Doctor not available at requested time');
    END IF;

    INSERT INTO APPOINTMENTS(patient_id, doctor_id, appt_time, status)
    VALUES (p_patient_id, p_doctor_id, p_time, 'SCHEDULED')
    RETURNING appt_id INTO p_appt_id;
  END;

  PROCEDURE cancel_appointment(p_appt_id IN NUMBER) IS
  BEGIN
    UPDATE APPOINTMENTS SET status='CANCELLED' WHERE appt_id=p_appt_id;
  END;
END pkg_appointments;
/

Trigger: Auto-calculate invoice total
CREATE OR REPLACE TRIGGER trg_billing_items_total
BEFORE INSERT OR UPDATE ON BILLING_ITEMS
FOR EACH ROW
BEGIN
  :NEW.line_total := NVL(:NEW.unit_price,0) * NVL(:NEW.qty,0);
END;
/

CREATE OR REPLACE TRIGGER trg_billing_total
AFTER INSERT OR UPDATE OR DELETE ON BILLING_ITEMS
FOR EACH ROW
DECLARE
  v_invoice_id NUMBER;
BEGIN
  v_invoice_id := COALESCE(:NEW.invoice_id, :OLD.invoice_id);
  UPDATE BILLING b
  SET b.amount = (SELECT NVL(SUM(line_total),0) FROM BILLING_ITEMS WHERE invoice_id=v_invoice_id),
      b.tax    = ROUND((SELECT NVL(SUM(line_total),0) FROM BILLING_ITEMS WHERE invoice_id=v_invoice_id) * 0.18, 2),
      b.total  = ROUND((b.amount + b.tax) - NVL(b.discount,0), 2)
  WHERE b.invoice_id = v_invoice_id;
END;
/

Audit Trigger (example)
CREATE OR REPLACE TRIGGER trg_appt_audit
AFTER INSERT OR UPDATE OR DELETE ON APPOINTMENTS
FOR EACH ROW
BEGIN
  INSERT INTO AUDIT_LOG(entity_name, entity_id, action, changed_by, changed_at)
  VALUES ('APPOINTMENTS',
          NVL(:NEW.appt_id, :OLD.appt_id),
          CASE WHEN INSERTING THEN 'INSERT' WHEN UPDATING THEN 'UPDATE' ELSE 'DELETE' END,
          USER,
          SYSDATE);
END;
/

API Endpoints

Base URL: /api/v1

Method	Endpoint	Description	Body/Params
GET	/patients	List patients	page,size
POST	/patients	Create patient	JSON
GET	/doctors	List doctors	—
POST	/appointments/book	Book appointment (calls package)	patient_id, doctor_id, appt_time
POST	/appointments/cancel	Cancel appointment	appt_id
GET	/billing/{invoice_id}	Get invoice + items	—
POST	/billing/{invoice_id}/items	Add billing item	item JSON

Flask snippet (cx_Oracle/oracledb):

from flask import Flask, request, jsonify
import oracledb

app = Flask(__name__)
conn = oracledb.connect(user="HMS_USER", password="***", dsn="localhost/XEPDB1")

@app.post("/api/v1/appointments/book")
def book_appt():
    data = request.get_json()
    with conn.cursor() as cur:
        appt_id = cur.var(oracledb.NUMBER)
        cur.callproc("pkg_appointments.book_appointment", [
            data["patient_id"], data["doctor_id"], data["appt_time"], appt_id
        ])
        conn.commit()
        return jsonify({"appt_id": int(appt_id.getvalue())}), 201

Setup & Installation
Prerequisites

Oracle 12c+ (XE works for dev)

Python 3.10+, oracledb (pip install oracledb)

Flask, python-dotenv

SQL*Plus / SQL Developer for running DDL

Steps

Create schema/user

CREATE USER hms_user IDENTIFIED BY "StrongPass123";
GRANT CONNECT, RESOURCE TO hms_user;
ALTER USER hms_user QUOTA UNLIMITED ON USERS;


Run DDL & PL/SQL

Execute scripts in /sql/01_tables.sql, /sql/02_constraints.sql, /sql/03_packages.sql, /sql/04_triggers.sql.

Configure API

Create .env:

ORACLE_DSN=localhost/XEPDB1
ORACLE_USER=hms_user
ORACLE_PASSWORD=StrongPass123
FLASK_ENV=development


Install & run

pip install -r requirements.txt
flask run

Sample Data & Queries
-- Seed data
INSERT INTO DOCTORS(first_name,last_name,specialization,is_active) VALUES ('Asha','Nair','Cardiology','Y');
INSERT INTO PATIENTS(first_name,last_name,dob,gender,phone) VALUES ('Ravi','Patel',DATE '1992-04-14','M','9998887777');

-- Book appointment via PL/SQL
DECLARE v_appt NUMBER; BEGIN
  pkg_appointments.book_appointment(1, 1, TO_DATE('2025-11-15 10:00','YYYY-MM-DD HH24:MI'), v_appt);
  DBMS_OUTPUT.PUT_LINE('Booked: '||v_appt);
END;
/

-- Create invoice and add items
INSERT INTO BILLING(patient_id, appt_id, discount, status) VALUES (1, 1, 0, 'OPEN') RETURNING invoice_id INTO :id;
-- Then add items; totals auto-calc by trigger


Analytical examples:

-- Daily revenue
SELECT TRUNC(created_at) AS day, SUM(total) AS revenue
FROM BILLING WHERE status='PAID'
GROUP BY TRUNC(created_at) ORDER BY day;

-- Doctor utilization (appointments/day)
SELECT d.doctor_id, d.first_name||' '||d.last_name AS doctor, COUNT(*) AS appts
FROM APPOINTMENTS a JOIN DOCTORS d ON d.doctor_id=a.doctor_id
WHERE a.status='COMPLETED' AND a.appt_time >= SYSDATE-30
GROUP BY d.doctor_id, d.first_name, d.last_name
ORDER BY appts DESC;

Performance & Indexing

Indexes: APPOINTMENTS(doctor_id, appt_time), BILLING(invoice_id), BILLING_ITEMS(invoice_id), PATIENTS(email)

Bind variables in API to avoid hard parses

EXPLAIN PLAN and SQL Monitor for slow queries

Periodic stats gathering: DBMS_STATS.gather_schema_stats('HMS_USER');

Testing

Unit tests (pytest) for API routes and PL/SQL (via anonymous blocks)

Integration tests: seed minimal data, exercise booking/cancel, billing totals

Negative tests: overlapping bookings, invalid foreign keys, trigger failures

Security

Least-privilege DB roles: separate HMS_APP (DML/EXECUTE) vs HMS_ADMIN (DDL)

Parameterized queries only

JWT on API endpoints (if exposed)

Mask PII in logs; never log full payloads of patient data

Backup & Recovery

Schema export with expdp/impdp

Nightly RMAN (if available)

Point-in-time recovery plan documented in /docs/backup.md

Project Structure
hms/
├─ api/
│  ├─ app.py
│  ├─ routes/
│  └─ services/
├─ sql/
│  ├─ 01_tables.sql
│  ├─ 02_constraints.sql
│  ├─ 03_packages.sql
│  └─ 04_triggers.sql
├─ docs/
│  ├─ erd.png
│  ├─ backup.md
│  └─ api-spec.md
├─ tests/
│  ├─ test_api.py
│  └─ test_plsql.sql
├─ .env.example
├─ requirements.txt
└─ README.md

Roadmap

Admit/Discharge/Transfer (ADT) module

Pharmacy inventory and e-prescriptions

Payment gateway integration

Role-based UI + dashboards (occupancy, revenue, cancellations)

CDC → Data warehouse for analytics (star schema)

License

MIT (or your chosen license)
